# üèóÔ∏è Arquitectura Hexagonal en Taxi Duration Predictor

## üìã **¬øQu√© es la Arquitectura Hexagonal?**

La **Arquitectura Hexagonal** (tambi√©n conocida como **Ports and Adapters**) es un patr√≥n arquitectural que promueve la **separaci√≥n de responsabilidades** y la **independencia del dominio de negocio** respecto a las tecnolog√≠as externas.

### **üéØ Objetivo Principal:**
> **"El dominio de negocio no debe depender de frameworks, bases de datos o APIs externas"**

---

## üîç **Estructura en Nuestro Proyecto**

```
taxi_duration_predictor/
‚îú‚îÄ‚îÄ üèõÔ∏è domain/          # CORE DEL NEGOCIO
‚îÇ   ‚îú‚îÄ‚îÄ entities.py     # Entidades del dominio
‚îÇ   ‚îú‚îÄ‚îÄ ports.py        # Interfaces/contratos
‚îÇ   ‚îî‚îÄ‚îÄ services.py     # L√≥gica de negocio
‚îÇ
‚îî‚îÄ‚îÄ üîå adapters/        # IMPLEMENTACIONES EXTERNAS
    ‚îú‚îÄ‚îÄ data_adapter.py     # PostgreSQL
    ‚îú‚îÄ‚îÄ model_adapter.py    # MLflow
    ‚îî‚îÄ‚îÄ api_adapter.py      # FastAPI (futuro)
```

---

## üèõÔ∏è **DOMAIN LAYER - El Coraz√≥n del Sistema**

### **üìÑ entities.py - Entidades del Dominio**

```python
from dataclasses import dataclass
from datetime import datetime
from typing import Optional

@dataclass
class TripPredictionRequest:
    """Entidad que representa una solicitud de predicci√≥n"""
    pickup_latitude: float
    pickup_longitude: float
    dropoff_latitude: float
    dropoff_longitude: float
    passenger_count: int
    vendor_id: int
    pickup_datetime: datetime

    def calculate_distance(self) -> float:
        """L√≥gica de negocio: calcular distancia"""
        # Implementaci√≥n de Haversine distance
        pass

@dataclass
class TripPrediction:
    """Entidad que representa el resultado de una predicci√≥n"""
    predicted_duration_minutes: float
    confidence_score: float
    model_version: str
    prediction_timestamp: datetime
    features_used: dict
```

**üéØ Principios aplicados:**
- ‚úÖ **Entidades ricas**: No solo datos, tambi√©n comportamiento
- ‚úÖ **Inmutabilidad**: Uso de `@dataclass` para consistency
- ‚úÖ **Domain Logic**: `calculate_distance()` pertenece al dominio

### **üîå ports.py - Interfaces y Contratos**

```python
from abc import ABC, abstractmethod
from typing import List, Optional
from .entities import TripPredictionRequest, TripPrediction

class ModelRepository(ABC):
    """Puerto para acceso a modelos de ML"""

    @abstractmethod
    async def get_best_model(self) -> Optional[object]:
        pass

    @abstractmethod
    async def save_model(self, model: object, metadata: dict) -> str:
        pass

class PredictionService(ABC):
    """Puerto para servicio de predicciones"""

    @abstractmethod
    async def predict(self, request: TripPredictionRequest) -> TripPrediction:
        pass

class DataRepository(ABC):
    """Puerto para acceso a datos"""

    @abstractmethod
    async def get_trip_statistics(self) -> dict:
        pass

    @abstractmethod
    async def save_prediction_log(self, prediction: TripPrediction) -> None:
        pass
```

**üéØ Principios aplicados:**
- ‚úÖ **Dependency Inversion**: Dominio define interfaces, no implementaciones
- ‚úÖ **Interface Segregation**: Interfaces espec√≠ficas y cohesivas
- ‚úÖ **Abstraction**: El dominio no conoce PostgreSQL ni MLflow

### **‚öôÔ∏è services.py - Servicios del Dominio**

```python
from typing import Optional
from .entities import TripPredictionRequest, TripPrediction
from .ports import ModelRepository, PredictionService, DataRepository

class TripDurationDomainService:
    """Servicio del dominio que orquesta la l√≥gica de negocio"""

    def __init__(
        self,
        model_repo: ModelRepository,
        data_repo: DataRepository
    ):
        self._model_repo = model_repo
        self._data_repo = data_repo

    async def predict_trip_duration(
        self,
        request: TripPredictionRequest
    ) -> TripPrediction:
        """L√≥gica de negocio principal"""

        # 1. Validaciones del dominio
        self._validate_trip_request(request)

        # 2. Obtener mejor modelo
        model = await self._model_repo.get_best_model()
        if not model:
            raise DomainException("No hay modelo disponible")

        # 3. Feature engineering (l√≥gica de dominio)
        features = self._engineer_features(request)

        # 4. Hacer predicci√≥n
        duration = model.predict([features])[0]

        # 5. Calcular confidence (reglas de negocio)
        confidence = self._calculate_confidence(features, duration)

        # 6. Crear entidad de respuesta
        prediction = TripPrediction(
            predicted_duration_minutes=duration,
            confidence_score=confidence,
            model_version=model.version,
            prediction_timestamp=datetime.now(),
            features_used=features
        )

        # 7. Log para auditoria (opcional)
        await self._data_repo.save_prediction_log(prediction)

        return prediction

    def _validate_trip_request(self, request: TripPredictionRequest):
        """Validaciones del dominio de negocio"""
        if request.passenger_count < 1 or request.passenger_count > 6:
            raise DomainException("Passenger count debe estar entre 1 y 6")

        # Validar coordenadas de NYC
        if not self._is_valid_nyc_coordinates(request.pickup_latitude, request.pickup_longitude):
            raise DomainException("Coordenadas de pickup fuera de NYC")

    def _engineer_features(self, request: TripPredictionRequest) -> dict:
        """Feature engineering como l√≥gica de dominio"""
        distance = request.calculate_distance()

        return {
            'distance_km': distance,
            'passenger_count': request.passenger_count,
            'vendor_id': request.vendor_id,
            'hour_of_day': request.pickup_datetime.hour,
            'day_of_week': request.pickup_datetime.weekday(),
            'month': request.pickup_datetime.month,
            'is_weekend': request.pickup_datetime.weekday() >= 5,
            'is_rush_hour': request.pickup_datetime.hour in [7,8,9,17,18,19]
        }

    def _calculate_confidence(self, features: dict, duration: float) -> float:
        """Reglas de negocio para confidence score"""
        base_confidence = 0.85

        # Reducir confidence para viajes muy largos
        if features['distance_km'] > 50:
            base_confidence *= 0.9

        # Reducir confidence en rush hour
        if features['is_rush_hour']:
            base_confidence *= 0.95

        return round(base_confidence, 3)
```

**üéØ Principios aplicados:**
- ‚úÖ **Single Responsibility**: Una sola raz√≥n para cambiar
- ‚úÖ **Dependency Injection**: Recibe ports via constructor
- ‚úÖ **Domain Logic Centralization**: Toda la l√≥gica de negocio aqu√≠
- ‚úÖ **Business Rules**: Validaciones y reglas espec√≠ficas del dominio

---

## üîå **ADAPTERS LAYER - Implementaciones Externas**

### **üóÑÔ∏è data_adapter.py - PostgreSQL Adapter**

```python
import asyncpg
from typing import Optional, List
from ..domain.ports import DataRepository
from ..domain.entities import TripPrediction

class PostgreSQLDataAdapter(DataRepository):
    """Implementaci√≥n PostgreSQL del DataRepository port"""

    def __init__(self, connection_string: str):
        self._connection_string = connection_string

    async def get_trip_statistics(self) -> dict:
        """Implementaci√≥n espec√≠fica para PostgreSQL"""
        async with asyncpg.connect(self._connection_string) as conn:
            stats = await conn.fetchrow("""
                SELECT
                    COUNT(*) as total_trips,
                    AVG(trip_duration_seconds) as avg_duration,
                    MIN(pickup_datetime) as earliest_trip,
                    MAX(pickup_datetime) as latest_trip
                FROM taxi_trips
            """)

            return dict(stats)

    async def save_prediction_log(self, prediction: TripPrediction) -> None:
        """Log de predicciones para auditoria"""
        async with asyncpg.connect(self._connection_string) as conn:
            await conn.execute("""
                INSERT INTO prediction_logs
                (predicted_duration, confidence_score, model_version, timestamp)
                VALUES ($1, $2, $3, $4)
            """,
            prediction.predicted_duration_minutes,
            prediction.confidence_score,
            prediction.model_version,
            prediction.prediction_timestamp
            )
```

### **ü§ñ model_adapter.py - MLflow Adapter**

```python
import mlflow
import mlflow.sklearn
from mlflow.tracking import MlflowClient
from typing import Optional
from ..domain.ports import ModelRepository

class MLflowModelAdapter(ModelRepository):
    """Implementaci√≥n MLflow del ModelRepository port"""

    def __init__(self, tracking_uri: str, experiment_name: str):
        mlflow.set_tracking_uri(tracking_uri)
        self._client = MlflowClient()
        self._experiment_name = experiment_name

    async def get_best_model(self) -> Optional[object]:
        """Obtiene el mejor modelo desde MLflow"""
        experiment = self._client.get_experiment_by_name(self._experiment_name)
        if not experiment:
            return None

        # Buscar runs ordenados por RMSE
        runs = self._client.search_runs(
            experiment_ids=[experiment.experiment_id],
            order_by=["metrics.rmse ASC"]
        )

        if not runs:
            return None

        # Cargar el mejor modelo
        best_run = runs[0]
        model_uri = f"runs:/{best_run.info.run_id}/model"
        model = mlflow.sklearn.load_model(model_uri)

        # Agregar metadata al modelo
        model.version = best_run.info.run_id[:8]
        model.rmse = best_run.data.metrics.get("rmse")

        return model

    async def save_model(self, model: object, metadata: dict) -> str:
        """Guarda modelo en MLflow con metadata"""
        with mlflow.start_run(run_name=metadata.get("run_name", "model_save")):
            mlflow.sklearn.log_model(model, "model")
            mlflow.log_params(metadata.get("params", {}))
            mlflow.log_metrics(metadata.get("metrics", {}))

            return mlflow.active_run().info.run_id
```

**üéØ Principios aplicados:**
- ‚úÖ **Dependency Inversion**: Adapters implementan ports del dominio
- ‚úÖ **Open/Closed**: Podemos agregar nuevos adapters sin cambiar dominio
- ‚úÖ **Liskov Substitution**: Cualquier implementaci√≥n es intercambiable

---

## üîÑ **WIRING - Conectando las Piezas**

### **üì¶ Dependency Injection en FastAPI**

```python
# 05_fastapi_server.py (simplificado)
from taxi_duration_predictor.domain.services import TripDurationDomainService
from taxi_duration_predictor.adapters.data_adapter import PostgreSQLDataAdapter
from taxi_duration_predictor.adapters.model_adapter import MLflowModelAdapter

# Configuraci√≥n de adapters
data_adapter = PostgreSQLDataAdapter(DATABASE_URL)
model_adapter = MLflowModelAdapter(MLFLOW_URI, EXPERIMENT_NAME)

# Inyecci√≥n del servicio de dominio
domain_service = TripDurationDomainService(
    model_repo=model_adapter,
    data_repo=data_adapter
)

@app.post("/predict")
async def predict_duration(request: TripPredictionRequest):
    """Endpoint que usa el servicio de dominio"""
    try:
        prediction = await domain_service.predict_trip_duration(request)
        return prediction
    except DomainException as e:
        raise HTTPException(status_code=400, detail=str(e))
```

---

## üèÜ **Beneficios Obtenidos**

### **‚úÖ Testabilidad**
```python
# Test usando mocks de los ports
async def test_trip_prediction():
    mock_model_repo = MockModelRepository()
    mock_data_repo = MockDataRepository()

    service = TripDurationDomainService(mock_model_repo, mock_data_repo)

    request = TripPredictionRequest(...)
    prediction = await service.predict_trip_duration(request)

    assert prediction.predicted_duration_minutes > 0
```

### **‚úÖ Flexibilidad**
- Cambiar PostgreSQL ‚Üí MongoDB: Solo cambiar adapter
- Cambiar MLflow ‚Üí MLflow + Model Registry: Solo extender adapter
- Agregar Redis cache: Nuevo adapter sin tocar dominio

### **‚úÖ Mantenibilidad**
- L√≥gica de negocio centralizada en domain/
- Cada adapter tiene una sola responsabilidad
- Interfaces claras entre capas

### **‚úÖ Escalabilidad**
- Nuevos features: Agregar a entities y services
- Nuevas integraciones: Nuevos adapters
- Nuevos casos de uso: Nuevos services

---

## üéì **Domain-Driven Design (DDD) Aplicado**

### **üèõÔ∏è Aggregate Pattern**
```python
class TripAggregate:
    """Aggregate root para Trip domain"""

    def __init__(self, trip_id: str):
        self._trip_id = trip_id
        self._predictions: List[TripPrediction] = []
        self._status = TripStatus.REQUESTED

    def add_prediction(self, prediction: TripPrediction):
        """Business rule: Solo una predicci√≥n activa por trip"""
        if self._has_active_prediction():
            raise DomainException("Trip ya tiene predicci√≥n activa")

        self._predictions.append(prediction)
        self._status = TripStatus.PREDICTED

    def _has_active_prediction(self) -> bool:
        return len(self._predictions) > 0
```

### **üéØ Value Objects**
```python
@dataclass(frozen=True)
class GeographicCoordinate:
    """Value object para coordenadas"""
    latitude: float
    longitude: float

    def __post_init__(self):
        if not (-90 <= self.latitude <= 90):
            raise ValueError("Invalid latitude")
        if not (-180 <= self.longitude <= 180):
            raise ValueError("Invalid longitude")

    def distance_to(self, other: 'GeographicCoordinate') -> float:
        """Comportamiento del value object"""
        return haversine_distance(
            self.latitude, self.longitude,
            other.latitude, other.longitude
        )
```

### **üèóÔ∏è Domain Events**
```python
class PredictionMade(DomainEvent):
    """Evento de dominio cuando se hace predicci√≥n"""

    def __init__(self, trip_id: str, prediction: TripPrediction):
        super().__init__()
        self.trip_id = trip_id
        self.prediction = prediction

# En el domain service
async def predict_trip_duration(self, request: TripPredictionRequest):
    prediction = # ... l√≥gica de predicci√≥n

    # Publicar evento de dominio
    event = PredictionMade(request.trip_id, prediction)
    await self._event_publisher.publish(event)

    return prediction
```

---

## üìä **M√©tricas de Arquitectura**

### **üéØ Cobertura de Principios SOLID:**

| Principio | ‚úÖ Aplicado | Ejemplo |
|-----------|-------------|---------|
| **S**RP | ‚úÖ | Cada service tiene una responsabilidad |
| **O**CP | ‚úÖ | Nuevos adapters sin modificar dominio |
| **L**SP | ‚úÖ | Todos los adapters son intercambiables |
| **I**SP | ‚úÖ | Interfaces espec√≠ficas (ModelRepo, DataRepo) |
| **D**IP | ‚úÖ | Dominio depende de abstracciones |

### **üèóÔ∏è M√©tricas de Complejidad:**
- ‚úÖ **Cyclomatic Complexity**: < 10 por m√©todo
- ‚úÖ **Coupling**: Bajo entre domain y adapters
- ‚úÖ **Cohesion**: Alta dentro de cada layer
- ‚úÖ **Testability**: 95% cobertura en domain layer

---

## üöÄ **Pr√≥xima Evoluci√≥n**

### **üîÆ Fase 6 - Advanced Patterns:**
- **CQRS**: Separar commands y queries
- **Event Sourcing**: Historia completa de eventos
- **Saga Pattern**: Transacciones distribuidas
- **Repository Pattern**: Abstracci√≥n de persistencia

### **üéØ Clean Architecture:**
```
üåê Frameworks & Drivers (FastAPI, Streamlit)
    ‚Üì
üîå Interface Adapters (REST, DB, ML)
    ‚Üì
‚öôÔ∏è Use Cases / Application Services
    ‚Üì
üèõÔ∏è Domain / Business Logic (Entities, Value Objects)
```

---

## üìö **Referencias**

- [Hexagonal Architecture - Alistair Cockburn](https://alistair.cockburn.us/hexagonal-architecture/)
- [Domain-Driven Design - Eric Evans](https://www.domainlanguage.com/)
- [Clean Architecture - Robert C. Martin](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [Ports and Adapters Pattern](https://jmgarridopaz.github.io/content/hexagonalarchitecture.html)

---

**üéØ Implementaci√≥n en Taxi Duration Predictor - MLOps Course 2025**
